Group #9 Assignment #4
	Jon Boone
	Joshua Datko
	Paul DeMicco
	Joseph Heenan
________________

OVERVIEW: Assignment #4
___________

This project builds upon project #3 which was a compiler developed targeting the RAL instruction set
that runs on the RAM simulator.

This package contains all of the files for Assignment #4.

=======
interpreterext.py		** Contains the grammar for the original mini language. Also contains the main method which
                        ** takes in a file and checks for the correct tokens and syntax.

                        ** p_program will call all of the methods required to translate, optimize and link the RAL
                        ** code to be used in the RAM simulator.

                        ** These text files will be generated as output (both when calling python interpretext.py < myinputfile and via calling make compile < myinputfile)
                        ** 1.) symOut.txt - Contains the symbolic RAL code prior to optimization and linking.
                        ** 2.) program-non-opt.txt - Contains the RAL code after linking is performed (but before optimization)
                        ** 3.) mem-dump.txt - Outputs the non-optimized memory table. Breaks down the VARS, CONSTS and TEMP variables stored in memory and and displays their name, and memory address.

programext.py			** Contains the implementation for the grammar along with all of the implementation for
                        ** generating the RAL code to be used in the RAM simulator.

makefile


                        ** view — display (using the more utility) all of your source code (excluding the modified RAM)
                        ** compile — Does whatever you need to do to produce:
                        *       symbolic RAL code
                        **      linked RAL code
                        ** view-trans — Use cat to display your symbolic RAL program (produced in translate) to stdout.
                        ** view-link — Use cat to display your compiled (not optimised) RAL program (produced in translate to stdout.
                        ** run — invoke ~jjohnson/bin/ram to run your program. Let output go to stdout.
                        ** clean — remove all binaries and intermediate files

README                  ** This file

    *** Application Notes ***

    The RAL instruction set has been expanded to now include all of the following calls:
        ADD = 'ADD'
        SUB = 'SUB'
        MUL = 'MUL'
        JMP = 'JMP'
        JMI = 'JMI'
        JMN = 'JMN'
        JMZ = 'JMZ'
        CAL = 'CAL'
        HLT = 'HLT'
        LDA = 'LDA'
        STA = 'STA'
        LDI = 'LDI'
        STI = 'STI'

    The call stack has been modified to store ActivationRecords which store parameters, local variables, temporary variables, etc. for
    procedures that are defined.

    A memory map of the following structure has been defined for this project:

    The stack pointer will always be stored at Address #1.
    The frame pointer will always be stored at Address #2.
    Frame pointer buffer will always be stored at Address #3.
    A temporary register will always be stored at Address #4.

    DefineStmt has been modified with a 'translate' method that will support procedures.
        The DefineStmt will add the function name to the function table along with creating a label
        so that we can jump back to that function.

    Proc has been modified with a 'translate' method so that function calls can be translated.
        Proc will create the ActivationRecord for the function and add the parameters needed for the
        function to the ActivationRecord along with storing all of the instructions needed for the function to be executed.

    FunCall has been modified with a 'translate' method so that function calls can be translated.
        FunCall will access the ActivationRecord created by Proc along with setting the stack and frame pointer.
        The function will be called at this time and the return value will be stored back into
        the AC register.

    The linker is still responsible for resolving actual addresses.
    The final output of the application will be non-optimized RAL code along with the memory table to be used as input into
    the RAL simulator.

OUTPUT
_________

After the program is run, a log file logfile.out is generated which describes why code was linked in the manner it was
symOut.txt is generated with symbolic RAL
program-non-opt.txt is generated with linked RAL
mem-dump.txt has the generated memory table

LIMITATIONS
___________

Recursion is not supported. Only the "main" function is properly writing values to the stack. Also, the "main" function must be explicitly defined

TEST FILES - Will be explained in detail below :
________________
assign1.p       ** Used to test the assignment of constants to variables.

When running this file, one can properly see output such as 600 at the bottom of the stack

easy_fun.p      ** Used to further test the main function; shows how Main can call another function. In the generated symbolic RAL (symOut.txt), one can see that the initial instuction stream calls main and then, once main returns, eventually executes HLT. main in turn calls easy, which returns to main.

easy_fun2.p     ** Shows further depth of stack calling; main calls a function which itself calls another function. In the generated symbolic RAL (symOut.txt) one can see that main calls easy, which in turn calls levelTwo. The nested calls all terminate correctly

RUNNING: Assignment #4, Part #1
___________

Executing make run < myinputfile (where you substitute myinputfile for an appropriate mini language input file) will compile and run myinputfile

Other included targets are view, compile, view-trans, view-link, view-op and clean to supporting viewing all source, compile/link/optimize of input on stdin, viewing symbolic RAL, viewing linked RAL, viewing optimized RAL, and cleaning output file, respectively

TESTING: Assignment #4, Part #1
___________
All test case files (*.p) have been run through the compiler to ensure proper operation (within the bounds of documented limitations). High-level code (CAL/JMI sequences, function label linking, etc) is working correctly although function returns do not appear to be working correctly (i.e., f1() calls f2()) as documented.
The output of the compiler has also been ran through the RAM simulator to validate the instructions have been generated properly.

RUBRIC NOTES:
________________
1. Updated symbol table
    20 points

        Note: We now have symbol storage (via using labels) that resolves at linktime; this allows us to implement the function calling convention documented in lecture, whereby frame pointer and stack pointer are updated as the frame grows

      2. Translation
    20 points

        Note: We translate code such that parameters are pushed to the bottom of the stack using an activation record object; temporaries follow this, followed by return_addr, return, and prev_fp entries. We store values relative to function pointers and stack pointers and include methods to emit prolog and epilog to FunCalls, so that nested function calls (i.e., a calls b calls c) can be made (with the caveat that return values aren't currently properly passed down the stack)

      3. Linking
    20 points

        Note: We implemented an is_jump function which checks whether the opcode of an unlinked machine code line refers to each a JMI/JMN/JMZ/JMP or a CAL, and if so, we find the label of that line at link-time and resolve it

      4. JMI in RAM simulator (already given, see announcement)
    0 point

      5. complie method
    10 points

        Note: We implemented function-aware compilation for DefineStmt, Proc, FunCall and modified how Program is translated accordingly. We changed the way we generate labels during compilation to ensure translated functions aren't placed "too early" in the instruction stream, just because they may be defined early

      6. Init PC in RAM, depending on how you low procedures
    10 points

        Note: We init the PC via using the CAL instruction. We link the address of main at compile-time and make sure to emit a CAL to main

      7. Output method that dumps the compiled RAL program
    10 points

      Documents: makefile, README, samle inputs, etc.

        Note: Here we document that, while the program doesn't work fully, we have a design that we feel that, with more time, could be evolved into a fully working program. Bottom-upwards stack growth, CAL with return via SP, and labelling of functions are all working in the code and described in this file

    10 points
