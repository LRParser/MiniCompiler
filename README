Group #9 Assignment #4
	Jon Boone
	Joshua Datko
	Paul DeMicco
	Joseph Heenan
________________

OVERVIEW: Assignment #4
___________

This project builds upon project #3 which was a compiler developed targeting the RAL instruction set
that runs on the RAM simulator.

This package contains all of the files for Assignment #4.

=======
interpreterext.py		** Contains the grammar for the original mini language. Also contains the main method which
                        ** takes in a file and checks for the correct tokens and syntax.

                        ** p_program will call all of the methods required to translate, optimize and link the RAL
                        ** code to be used in the RAM simulator.

                        ** These text files will be generated as output (both when calling python interpretext.py < myinputfile and via calling make compile < myinputfile)
                        ** 1.) symOut.txt - Contains the symbolic RAL code prior to optimization and linking.
                        ** 2.) program-non-opt.txt - Contains the RAL code after linking is performed (but before optimization)
                        ** 3.) mem-dump.txt - Outputs the non-optimized memory table. Breaks down the VARS, CONSTS and TEMP variables stored in memory and and displays their name, and memory address.

programext.py			** Contains the implementation for the grammar along with all of the implementation for
                        ** generating the RAL code to be used in the RAM simulator.

makefile


                        ** view — display (using the more utility) all of your source code (excluding the modified RAM)
                        ** compile — Does whatever you need to do to produce:
                        *       symbolic RAL code
                        **      linked RAL code
                        ** view-trans — Use cat to display your symbolic RAL program (produced in translate) to stdout.
                        ** view-link — Use cat to display your compiled (not optimised) RAL program (produced in translate to stdout.
                        ** run — invoke ~jjohnson/bin/ram to run your program. Let output go to stdout.
                        ** clean — remove all binaries and intermediate files

README                  ** This file

    *** Application Notes ***

    The RAL instruction set has been expanded to now include all of the following calls:
        ADD = 'ADD'
        SUB = 'SUB'
        MUL = 'MUL'
        JMP = 'JMP'
        JMI = 'JMI'
        JMN = 'JMN'
        JMZ = 'JMZ'
        CAL = 'CAL'
        HLT = 'HLT'
        LDA = 'LDA'
        STA = 'STA'
        LDI = 'LDI'
        STI = 'STI'

    The call stack has been modified to store ActivationRecords which store parameters, local variables, temporary variables, etc. for
    procedures that are defined.

    A memory map of the following structure has been defined for this project:

    The stack pointer will always be stored at Address #1.
    The frame pointer will always be stored at Address #2.
    Frame pointer buffer will always be stored at Address #3.
    A temporary register will always be stored at Address #4.

    DefineStmt has been modified with a 'translate' method that will support procedures.
        The DefineStmt will add the function name to the function table along with creating a label
        so that we can jump back to that function.

    Proc has been modified with a 'translate' method so that function calls can be translated.
        Proc will create the ActivationRecord for the function and add the parameters needed for the
        function to the ActivationRecord along with storing all of the instructions needed for the function to be executed.

    FunCall has been modified with a 'translate' method so that function calls can be translated.
        FunCall will access the ActivationRecord created by Proc along with setting the stack and frame pointer.
        The function will be called at this time and the return value will be stored back into
        the AC register.

    The linker is still responsible for resolving actual addresses.
    The final output of the application will be non-optimized RAL code along with the memory table to be used as input into
    the RAL simulator.

OUTPUT
_________

After the program is run, a log file logfile.out is generated which describes why code was linked in the manner it was
symOut.txt is generated with symbolic RAL
program-non-opt.txt is generated with linked RAL
mem-dump.txt has the generated memory table

LIMITATIONS
___________

Recursion is not supported. Only the "main" function is properly writing values to the stack. Also, the "main" function must be explicitly defined

TEST FILES - Will be explained in detail below :
________________
assign1.p       ** Used to test the assignment of constants to variables.

When running this file, one can properly see output such as 600 at the bottom of the stack

MainFunc.p      ** Used to further test the main function

RUNNING: Assignment #4, Part #1
___________

Executing make run < myinputfile (where you substitute myinputfile for an appropriate mini language input file) will compile and run myinputfile

Other included targets are view, compile, view-trans, view-link, view-op and clean to supporting viewing all source, compile/link/optimize of input on stdin, viewing symbolic RAL, viewing linked RAL, viewing optimized RAL, and cleaning output file, respectively

TESTING: Assignment #4, Part #1
___________
All test case files (*.p) have been run through the compiler to ensure proper operation (within the bounds of documented limitations). High-level code (CAL/JMI sequences, function label linking, etc) is working correctly although function returns do not appear to be working correctly (i.e., f1() calls f2()) as documented.
The output of the compiler has also been ran through the RAM simulator to validate the instructions have been generated properly.

RUBRIC NOTES:
________________
1. Updated symbol table
    20 points

      2. Translation
    20 points

      3. Linking
    20 points

      4. JMI in RAM simulator (already given, see announcement)
    0 point

      5. complie method
    10 points

      6. Init PC in RAM, depending on how you low procedures
    10 points

      7. Output method that dumps the compiled RAL program
    10 points

      Documents: makefile, README, samle inputs, etc.
    10 points
